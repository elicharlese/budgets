# How to perform a Sell flow

In this guide, we will see how to securly _sell_ cryptoassets to a third party service in exchange for fiat currency.

## Get the user account from which to perform a transfer operation

Get the user [Account](https://github.com/LedgerHQ/live-app-sdk/blob/main/docs/reference/modules.md#account) from which to perform a transfer operation.

You can get an account using either [`listAccount`](https://github.com/LedgerHQ/live-app-sdk/blob/main/docs/reference/classes/LedgerLivePlatformSDK.md#listaccounts) or [`requestaccount`](https://github.com/LedgerHQ/live-app-sdk/blob/main/docs/reference/classes/LedgerLivePlatformSDK.md#requestaccount).

## Get a unique transaction id from the device

The first step to start the exchange process is to call the `startExchange` function with the appropriate [`exchangeType`](https://github.com/LedgerHQ/live-app-sdk/blob/main/docs/reference/enums/ExchangeType.md). This will return a transaction ID that will be used to complete the exchange process.

```ts
const transactionId = await SDK.startExchange({
  exchangeType: ExchangeType.SELL,
});
```

## Create the operation transaction

Then, you will need to create the [transaction](https://github.com/LedgerHQ/live-app-sdk/blob/main/docs/reference/modules.md#transaction) associated to the operation you want to perform.

In the case of a _sell_ operation, the transaction `recipient` address should be the address to which you expect to receive the user funds.

```ts
// Example for a BTC transaction
const transaction: BitcoinTransaction = {
  amount: new BigNumber(1), // Correspond to 1 satoshi or 0.00000001 BTC
  recipient: "YOUR_BTC_ADDRESS",
  family: FAMILIES.BITCOIN,
};
```

## Generate the payload and signature

The `binaryPayload` is a protobuf message containing the transaction data. It is generated by you, the provider, and sent to the device through Ledger Live.

Your protobuf message should have the following structure:

```protobuf
// (coefficient) * 10^(- exponent)
message UDecimal {
    bytes  coefficient = 1;
    uint32 exponent = 2;
}

message NewSellResponse {
    string   trader_email = 1;           // traderEmail
    string   in_currency = 2;            // inCurrency
    bytes    in_amount = 3;              // inAmount
    string   in_address = 4;             // account
    string   out_currency = 5;           // outCurrency
    UDecimal out_amount = 6;             // outAmount
    bytes    device_transaction_id = 7;  // nonce
}
```

### Explanation of each fields:

- `trader_email`

  An email address used to identify of the user on the third party service provider.

  Should be known by the user since it **will be displayed on the device for validation purposes.**.

- `in_currency`

  The currency ticker that the client wants to sell (example: `BTC`).

  **Will be displayed on the device for validation purposes.**

- `in_amount`

  The amount of `in_currency` that the client wants to sell, in the lowest unit of the coin, encoded into a 16 bytes array in big-endian format.

  **Will be displayed on the device for validation purposes.**

  Examples:

  - For 1 **BTC**:

    1. the smallest unit is a **satoshi** which is `10^-8` **BTC**
    2. multiply the amount by this smallest unit: `1 * 10^8 = 100000000`
    3. convert to hexadecimal: `100000000` in decimal is `0x5F5E100` in hexadecimal
    4. encode this value in a 16 bytes array in big endian: `[0x00, ..., 0x00, 0x05, 0xF5, 0xE1, 0x00]`

  - For 2 **ETH**:

    1. the smallest unit is a **wei** which is `10^-18` **ETH**
    2. multiply the amount by this smallest unit: `2 * 10^18 = 2000000000000000000`
    3. convert to hexadecimal: `2000000000000000000` in decimal is `0x1BC16D674EC80000` in hexadecimal
    4. encode this value in a 16 bytes array in big endian: `[0x00, ... 0x00, 0x1B, 0xC1, 0x6D, 0x67, 0x4E, 0xC8, 0x00, 0x00]`

- `in_address`

  The blockchain address to which you expect to received the user cryptoassets.

- `out_currency`

  The fiat currency ticker that the client wants to sell his assets against (example: `USD`).

  **Will be displayed on the device for validation purposes.**

- `out_amount`

  The amount of `out_currency` that the client is expected to receive, as a `UDecimal` protobuf message (cf. definition above).

  The `coefficient` part is, like the `in_amount` above, the hexadecimal ammount encoded into a 16 bytes array in big-endian format.

  For example, to represent `10.25`, which is `1025 * 10^(-2)`, the `coefficient` would be `1025` (encoded into a 16 bytes array in big-endian format) and the `exponent` would be `2`.

  **Will be displayed on the device for validation purposes.**

- `device_transaction_id`

  The transaction nonce generated on the device and returned by the `startExchange` function, encoded in Base64 following [RFC_4648](https://en.wikipedia.org/wiki/Base64#RFC_4648).

### Payloads generation

How are `binaryPayload` and it's `signature` generated?

Here is a diagram to explain this:

![Payload and Payload Signature generation diagram](https://developers.ledger.com/docs/platform-app/images/funding-payload-signature-generation.png)

- `binaryPayload`: The transaction data's parameters are assembled in a [protobuf](https://developers.google.com/protocol-buffers) message. Then using the protobuf tools you can do a [binary encoding](https://developers.google.com/protocol-buffers/docs/encoding) of the protobuf (Byte Array). Finally, with [Base64 encoding](https://en.wikipedia.org/wiki/Base64) you get the `binaryPayload` field.

- `signature`: From the binary encoding of the previous [protobuf](https://developers.google.com/protocol-buffers) (Byte Array), you sign it with [ES256](https://ldapwiki.com/wiki/ES256) and your private key to get a Signature Byte Array. Finally, with [Base64 encoding](https://en.wikipedia.org/wiki/Base64) you get the `signature` field.

## Complete the exchange

To complete the exchange (i.e: ask the user to verify the informations, sign the transaction and broadcast it to the network), the last step is to call the [`completeExchange`](https://github.com/LedgerHQ/live-app-sdk/blob/main/docs/reference/classes/LedgerLivePlatformSDK.md#completeexchange) function, using all the information gathered or generated in the previous steps.

```ts
// Your unique ledger related provider id defined with the Ledger integration team
const provider = "YOUR_PROVIDER_ID";

const rawSignedTransaction = await SDK.completeExchange({
  provider,
  fromAccountId: account.id,
  transaction,
  binaryPayload,
  signature,
  feesStrategy: FeesLevel.Medium,
  exchangeType: ExchangeType.SELL,
});
```

## Working example

In order to better understand the process and test your own generated payload, feel free to have a look at our [test app](https://github.com/LedgerHQ/platform-app-test-exchange).
